---
description: Here we record what we've learned about this codebase whenever we run into difficulties.
globs:
alwaysApply: false
---

### Learning: Synchronizing Chart and Table Filters with TanStack Table

**Date:** 2024-07-26

**Feature:** Implementing interactive filtering where clicking a chart legend filters a TanStack React Table, specifically on the `/injury/entanglement/age` page.

#### Problem / Symptom

After refactoring the page to connect the chart's legend to the table's filters, a React concurrent rendering error occurred. This error only happened when using the multi-select filters for "Injury Description" and "Injury Severity" in the filter panel, but not for the "Age Class" filter which was also a multi-select.

The error message was:
```
Error: There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.
```

#### Root Cause Analysis

The error was caused by a data type mismatch between the value provided by the filter UI and the filtering function (`filterFn`) expected by the table's column definition.

1.  **Filter UI (`InjuryTableFilters.tsx`):** The `Select` component, when configured with `isMulti: true`, passes an **array of strings** (e.g., `['Gear', 'No Gear']`) to the table's filter state for that column.
2.  **Table Column Definition (`.../age/page.tsx`):** The column definitions for `InjuryAccountDescription` and `InjurySeverityDescription` were incorrectly configured with `filterFn: 'equalsString'`. This function expects a single string as its filter value and performs a strict equality check (`===`).
3.  **The Conflict:** The table attempted to compare a row's string value against an array of filter values using a function designed for string-to-string comparison. This mismatch caused an unstable state during the filtering process, triggering React's concurrent rendering error.

The "Age Class" filter worked correctly because its `filterFn` had already been updated to `'arrIncludesSome'`, which is designed to check for the inclusion of a value within an array.

#### Solution

The fix was to ensure the `filterFn` for each column matched the data type being passed by its corresponding filter component. In this case, we changed the filter function for the multi-select columns to one that handles arrays.

-   In `src/app/injury/entanglement/age/page.tsx`, the `filterFn` for `InjuryAccountDescription` and `InjurySeverityDescription` was changed from `'equalsString'` to `'arrIncludesSome'`.

#### Key Takeaway

When implementing custom or complex filtering with TanStack Table, **always ensure the `filterFn` for a column is compatible with the data type and structure of the filter value being provided by the UI.**

-   **Multi-Select Dropdowns:** Will pass an array. Use a `filterFn` like `'arrIncludesSome'`, `'arrIncludesAll'`, or a custom function that iterates over the array.
-   **Text Inputs:** Will pass a string. Use `'includesString'`, `'equalsString'`, etc.
-   **Range Sliders:** Will pass a tuple (e.g., `[min, max]`). Requires a custom `filterFn` to check if the row's value is within the range.

A quick way to debug this in the future is to inspect the table's `columnFilters` state in React DevTools to see the exact structure of the value being set by the UI.

Of course. Here is a learning document entry explaining the architectural pattern for implementing two-way filtering between charts and a data table in this repository.

---

### Learning: Implementing Two-Way Synchronization Between Charts and a Data Table

**Date:** 2024-07-26

**Feature:** Creating an interactive data exploration experience where filtering the data table updates the charts, and interacting with the chart legends filters the data table. This was implemented on pages like `/injury/entanglement/age` and `/injury/entanglement/timeframe`.

#### Core Architectural Pattern

The key to this feature is establishing the **TanStack Table instance as the single source of truth for the filtered data.** Both the charts and the filter UI act as controllers that manipulate the table's filter state. The chart is simply a reactive visualization of the table's currently filtered data.

The data flow follows this pattern:

1.  A **Parent Page Component** holds all the state and logic.
2.  The parent initializes the `useReactTable` hook, managing its `columnFilters` state.
3.  The parent fetches the raw data and, if necessary, pre-processes it (e.g., creating categorical bins like `timeframeBin` from numerical data).
4.  The **`InjuryTableFilters` component** receives the `table` instance and updates its column filters directly when the user interacts with inputs or dropdowns.
5.  The **`DataChart` component** receives the *result* of the table's filtering (`table.getFilteredRowModel().rows`) as its primary data source. This ensures the chart always reflects the filtered state of the table.
6.  When a user clicks a legend item in the **`DataChart`**, it triggers a callback function (`onHiddenSeriesChange`).
7.  The **Parent Page Component** receives this callback, translates the chart interaction (e.g., a set of hidden series names) into a valid `ColumnFilter` that the table can understand, and updates the table's `columnFilters` state.
8.  This state update causes the table to re-filter its data, which in turn causes the `DataChart` to re-render with the new data, closing the loop.

#### Conceptual Implementation Steps for a Future AI

To replicate this feature on a new page, follow these conceptual steps:

1.  **Structure the Page Component:**
    *   The main page component (e.g., `.../age/page.tsx`) should be the owner of all state and logic.
    *   Do not use the generic `InjuryExplorerPage.tsx` component, as it abstracts away the necessary state control.
    *   Fetch and hold the raw dataset within this component.

2.  **Pre-process Data (If Necessary):**
    *   If the chart is based on categorical bins derived from raw data (e.g., `InjuryTimeFrame` number -> `timeframeBin` string), create a `useMemo` hook to map the raw data to a new "processed" dataset that includes these new properties. This processed data will be passed to the table.

3.  **Initialize the Table State:**
    *   Use the `useState` hook in the parent component to manage the table's `sorting` and `columnFilters` state.
    *   Instantiate the `useReactTable` hook, passing it the processed data and the state variables.

4.  **Define Table Columns Correctly:**
    *   Create the `columns` definition using `createColumnHelper`.
    *   **Crucially, ensure the `filterFn` for each column matches the data type and structure provided by its filter UI.**
        *   For multi-select dropdowns, use `filterFn: 'arrIncludesSome'`.
        *   For text inputs, use `filterFn: 'includesString'`.
        *   For range sliders, use a custom function that checks if the row's value is between the `[min, max]` values in the filter array.
    *   This is the most common point of failure. Mismatches here lead to React concurrent rendering errors.

5.  **Connect the Table and Filters UI:**
    *   Pass the fully instantiated `table` object to the `<InjuryTable>` and `<InjuryTableFilters>` components. The filters component is designed to read the column definitions and render the appropriate UI elements automatically.

6.  **Connect the Table to the Chart:**
    *   Create a `useMemo` hook that derives the chart's data directly from the table's filtered output: `table.getFilteredRowModel().rows.map(row => row.original)`.
    *   Pass this derived `chartData` to the `<DataChart>` component.

7.  **Implement the Chart-to-Table Callback:**
    *   Pass a callback function (e.g., `handleHiddenSeriesChange`) to the `onHiddenSeriesChange` prop of the `<DataChart>` component.
    *   Inside this callback function in the parent component:
        a.  Receive the set of hidden series from the chart.
        b.  Translate this set into a filter value that the table's column can understand. For example, create an array of *visible* series names.
        c.  Use `table.getColumn('columnId').setFilterValue()` to apply the new filter to the table. This will trigger a re-render of both the table and the chart.

By following this pattern, you create a robust, reactive system where the table's state is the central authority, and both the chart and filter UI act as intuitive controllers for manipulating that state.

@`.cursor/rules/learnings.mdc`

Here is the learning entry to be added:

### Learning: Implementing Two-Way Synchronization Between Charts and a Data Table

**Date:** 2024-07-27

**Feature:** Creating an interactive data exploration experience where filtering the data table updates the charts, and interacting with the chart legends filters the data table. This pattern was applied to `/injury/vessel-strike/type-and-severity`, using `/injury/entanglement/type-and-severity` as a model.

#### Core Architectural Pattern

The key to this feature is establishing the **TanStack Table instance as the single source of truth for the filtered data.** The data flow is unidirectional and cyclical: UI interactions modify the table's state, and the UI components (including the chart) reactively render based on that state.

1.  **Centralized State Management:** The parent page component (e.g., `.../page.tsx`) is responsible for all state management. It initializes and controls the `columnFilters` state for the `useReactTable` hook. State is not managed within the child components.

2.  **Table as the Source of Truth:**
    *   The `useReactTable` hook receives the full dataset and the `columnFilters` state.
    *   All filtering logic is handled by the table instance.
    *   The data table UI (`<InjuryTable>`) and the chart UI (`<DataChart>`) are both consumers of the table's filtered results.

3.  **Data Flow Loop:**
    *   **UI to Table:** The `<InjuryTableFilters>` component receives the `table` instance and calls `column.setFilterValue()` when a user interacts with a filter control.
    *   **Table to UI:** This state change causes the table to re-filter its data. A `useMemo` hook in the parent component, which depends on `table.getFilteredRowModel().rows`, re-calculates the data to be displayed in both the table and the charts. This triggers a re-render.
    *   **Chart to Table:** When a user clicks a chart legend, the `<DataChart>` component fires an `onHiddenSeriesChange` callback. The parent component receives this event, translates the set of "hidden series" into an array of "visible series," and calls `table.getColumn(...).setFilterValue()` to update the table's state, thus completing the loop.

#### Key Implementation Elements

1.  **Parent Component as Orchestrator:** The page component must manage the `useState` for `columnFilters` and pass it to `useReactTable`. It also defines the callback functions that translate UI events into table state changes.

2.  **Derived Chart Data:** The data passed to the `<DataChart>` component is not the raw dataset but is derived from the table's current filtered state. This is a critical step, achieved with `useMemo`:
    ```javascript
    const tableFilteredData = useMemo(
      () => table.getFilteredRowModel().rows.map((row) => row.original),
      [table.getFilteredRowModel().rows]
    );
    ```

3.  **Chart Interaction Callback (`onHiddenSeriesChange`):** The chart component is given a function prop that allows it to communicate user interactions back to the parent. The parent component contains the logic to update the table's filter state.
    ```javascript
    const handleHiddenSeriesChange = useCallback((hiddenSeries) => {
        const column = table.getColumn('columnId');
        // ... logic to derive filter value from hiddenSeries
        column.setFilterValue(derivedValue);
    }, [table]);
    ```

4.  **Correct `filterFn`:** The column definitions (`columns.ts` or inline) must use the correct `filterFn` for the data type being passed by the filter UI. For multi-select dropdowns that pass an array of strings, `filterFn: 'arrIncludesSome'` is essential to prevent rendering errors.

